{#
 # @prop {string} [aspectRatio] - ex., "1.75"
 # @prop {boolean} [autoplay]
 # @prop {string} [caption]
 # @prop {boolean} [fade]
 # @prop {Object[]} frames - Array of frame definitions
 # @prop {string} id
 # @prop {boolean} [loop]
 # @prop {boolean} [pointer]
 # @prop {boolean} [printedEffect]
 # @callable false
 #}
{% macro render( props ) %}
<figure
	x-data="PhoneApp({
		id: '{{ props.id }}',
		autoplay: {{ props.autoplay === true }},
		frames: {{ props.frames | dump | safe | replace( '"', "'" ) }},
		loop: {{ props.loop === true }},
	})
	"
	x-init="$watch( 'frameIndex', () => framestart() )"

	id="{{ props.id }}"
	class="[ center stack-sm ][ --measure ][ Phone {{ 'Phone--printed' if props.printedEffect else '' }} ]"
	style="--aspect-ratio: {{ props.aspectRatio if props.aspectRatio else '1.0' }};"
>
	<div class="[ center ][][ Phone-body {{ 'Phone-body--faded' if props.fade else '' }} ]">
		<div
			x-bind:style="screens.style"
			x-on:transitionend="frametransitionend"

			data-framerun="true"

			class="[][][ Phone-screen ]"
			style="--screen-bottom-background: url( {{ props.frames[0].screens.bottom.background }} ); --screen-pointer-x: {{ props.frames[0].screens.pointer.x }}; --screen-pointer-y: {{ props.frames[0].screens.pointer.y }};"
		>
			{% if props.pointer %}
			<div
				class="[][][ Phone-pointer ]"
			></div>
			{% endif %}
		</div>
	</div>

	{% if props.caption %}
	<figcaption
		class="[ center ][ measure text-center {{ 'visually-hidden' if props.hideCaption else '' }} ][]"
	>{{ props.caption | safe }}</figcaption>
	{% endif %}
</figure>
{% endmacro %}

{% set criticalStyles %}
<style>
	.Phone {
		max-width: calc( var( --measure-size) - 5em );
	}

	.Phone--printed {
		mix-blend-mode: multiply;
	}

	.Phone-body {
		--width: 90%;

		position: relative;
		overflow-y: hidden;

		height: 0;
		width: var( --width );
		padding-top: calc( var( --aspect-ratio ) * var( --width ) );
	}
		/* Device body */
		.Phone-body::after {
			content: "";
			display: block;
			position: absolute;
			top: 0; right: 0; bottom: 0; left: 0;

			filter: grayscale( 0.25 );

			background-position: top center;
			background-size: 100%;
			background-image:
				url( /images/iphone-frame-outside.svg ),
				url( /images/iphone-frame-inside.svg )
			;
			background-repeat: no-repeat;
		}

		.Phone--printed .Phone-body::after {
			filter: grayscale( 1 );
		}

		/* Fade effect */
		.Phone-body--faded::before {
			--height: 100px;

			z-index: 10;
			content: "";
			display: "block";
			position: absolute;
			right: 0; bottom: 0; left: 0;
			height: var( --height );

			background-color: white;

			-webkit-mask-image: url( /images/iphone-mask-gradient.png );
			-webkit-mask-size: 100% var( --height );
			-webkit-mask-repeat: no-repeat;
			mask-image: url( /images/iphone-mask-gradient.png );
			mask-size: 100% var( --height );
			mask-repeat: no-repeat;
		}

	/* Pointer */
	.Phone-pointer {
		--screen-pointer-x-min: 0.055;
		--screen-pointer-y-min: 0.0275;

		--size: 15; /* A percentage of the device width */
		--size-coefficient: calc( 100 / var( --size ) );

		filter: grayscale( 0.25 );

		position: relative;
		transform: translate(
				calc(
					(100% * var( --size-coefficient )) * var( --screen-pointer-x-min ) +
					(100% * var( --size-coefficient )) * var( --screen-pointer-x, 0.0 )
				),
				calc(
					(100% * var( --size-coefficient )) * var( --screen-pointer-y-min ) * {{ props.aspectRatio }} +
					(100% * var( --size-coefficient )) * var( --screen-pointer-y, 0.0 ) * {{ props.aspectRatio }}
				)
			)
		;

		height: 0;
		width: calc( var( --size ) * 1% );
		padding-bottom: calc( var( --size ) * 1% );

		transition: transform 0.875s ease;
	}
		.Phone-pointer::after {
			/*
			 * Animating the scale of the "child" element instead of its parent
			 * prevents the %-based x/y translation from causing the pointer
			 * to jump all over the place.
			 */
			content: "";
			display: block;
			position: absolute;
			top: 0; right: 0; bottom: 0; left: 0;

			border-radius: 50%;
			background-color: var( --color-teal );

			transform: scale( var( --screen-pointer-scale, 1 ) );
			opacity: var( --screen-pointer-opacity, 0.675 );

			transition: transform 0.20s ease, opacity 0.20s ease;
		}

	/* Both Screens */
	.Phone-screen,
	.Phone-screen::before {
		display: block;
		position: absolute;
		top: 0; right: 0; bottom: 0; left: 0;

		background-position: top center;
		background-size: calc( 100% + 2px );
		background-repeat: no-repeat;
		transition: opacity 0.75s ease;
	}

	/* Top Screen */
	.Phone-screen::before {
		background-image: var( --screen-top-background );
		opacity: var( --screen-top-opacity );

		content: "";
	}

	/* Bottom Screen */
	.Phone-screen {
		background-image: var( --screen-bottom-background );
		opacity: var( --screen-bottom-opacity );

		/* Styles for the entire element */
		filter: grayscale( 0.25 );
	}

	.Phone figcaption {
		--measure-size: 40ch;
		font-size: calc( var( --font-size ) );
	}
</style>
{% endset %}

{% set asyncScripts = [
	{
		src: "https://unpkg.com/alpinejs@3.4.1/dist/cdn.min.js",
		defer: true
	}
]%}

{% set criticalScript %}
<script>
	let PhoneApp = ({id, autoplay, frames=[], loop} = {}) =>
	{
		return {
			get currentFrame()
			{
				return this.frames[this.frameIndex];
			},

			autoplay: autoplay,
			frameIndex: 0,
			frames: frames,
			loop: loop,

			screens: {
				top: {},
				bottom: {},

				pointer: {
					x: 0.0,
					y: 0.0,
				},

				get style()
				{
					let styles = [
						`--screen-top-background: url( ${this.top.background} )`,
						`--screen-top-opacity: ${this.top.opacity}`,
						`--screen-bottom-background: url( ${this.bottom.background} )`,
						`--screen-bottom-opacity: ${this.bottom.opacity}`,
						`--screen-pointer-x: ${this.pointer.x}`,
						`--screen-pointer-y: ${this.pointer.y}`,
					];

					if( this.pointer.tapDown )
					{
						styles.push( `--screen-pointer-scale: 0.875` );
						styles.push( `--screen-pointer-opacity: 0.875` );
					}

					return styles.join( "; " );
				},
			},

			init()
			{
				this.framestart();
			},

			frameend()
			{
				if( this.autoplay )
				{
					if( this.frameIndex >= this.frames.length - 1 )
					{
						if( this.loop )
						{
							this.frameIndex = 0;
						}
					}
					else
					{
						this.frameIndex++;
					}
				}
			},

			framerun()
			{
				if( this.currentFrame.duration )
				{
					setTimeout( () =>
					{
						this.frameend();

					}, this.currentFrame.duration );
				}
				else
				{
					this.frameend();
				}
			},

			framestart()
			{
				this.screens.top = Object.assign(
					this.screens.top,
					this.currentFrame.screens.top || {}
				);
				this.screens.bottom = Object.assign(
					this.screens.bottom,
					this.currentFrame.screens.bottom || {}
				);
				this.screens.pointer = Object.assign(
					this.screens.pointer,
					this.currentFrame.screens.pointer || {}
				);

				let willTransition = true;
				willTransition = willTransition && this.frameIndex > 0;
				willTransition = willTransition && this.currentFrame.screens.top;
				willTransition = willTransition && this.currentFrame.screens.top.opacity !== undefined;

				// If the top screen isn't transitioning this frame, move along
				if( !willTransition )
				{
					this.framerun( this.currentFrame.id );
				}
			},

			frametransitionend( event )
			{
				// Don't transition after setting values for the initial frame
				if( this.frameIndex > 0 && event.target.dataset.framerun )
				{
					this.framerun();
				}
			},
		}
	}
</script>
{% endset %}
